"""Passphrase - Generates cryptographically secure passphrases and passwords

Passphrases are built by picking from a word list using cryptographically
secure random number generator. Passwords are built from printable characters.
by HacKan (https://hackan.net) under GNU GPL v3.0+
"""

from sys import version_info, exit as sys_exit
from .settings import ENTROPY_BITS_MIN
from .passphrase import Passphrase
from .aux import Aux
import argparse

__author__ = "HacKan"
__license__ = "GNU GPL 3.0+"
__version__ = "0.4.7"

assert (version_info >= (3, 2)), "This script requires Python 3.2+"


def print_version() -> None:
    print("Passphrase v{}\nby HacKan (https://hackan.net) FOSS under GNU "
          "GPL v3.0 or newer".format(__version__))


def bigger_than_zero(value: int) -> int:
    ivalue = int(value)
    if ivalue < 0:
        raise argparse.ArgumentTypeError(
            "{} should be bigger than 0".format(ivalue)
        )
    return ivalue


def main():
    passphrase = Passphrase()

    passphrase.entropy_bits_req = ENTROPY_BITS_MIN
    PASSWD_LEN_MIN_GOOD = passphrase.password_length_needed()
    WORDS_AMOUNT_MIN_DEFAULT = 6  # Just for EFF's Large Wordlist
    NUMS_AMOUNT_MIN_DEFAULT = 0

    parser = argparse.ArgumentParser(
        formatter_class=argparse.RawDescriptionHelpFormatter,
        description='Passphrase v{version} - Copyright HacKan '
        '(https://hackan.net) GNU GPL v3.0+.\n\n'
        'Generates a cryptographically secure passphrase, based on '
        'a wordlist, or a\npassword, and prints it to standard output.\n'
        'By default, it uses an embedded EFF Large Wordlist for passphrases.\n'
        'Passphrases with less than {wordsamountmin} words are considered '
        'insecure. A safe bet is \nbetween {wordsamountmin} and 7 words, '
        'plus at least a number.\n'
        'For passwords, use at least {passwdmin} characters, but prefer '
        '{passwdpref} or more, using the\ncomplete characters set.\n\n'
        'Instead of words and numbers, a password (random string of '
        'printable\ncharacters from Python String standard) can be generated '
        'by\n-p | --password, specifying the length. It uses uppercase, '
        'lowercase, digits\nand punctuation characters unless otherwise '
        'specified.\n'
        'Also, a UUID v4 string can be generated by --uuid4.\n'
        'A custom wordlist can be specified by -i | --input, the format must '
        'be: \nsingle column, one word per line. If -d | --diceware is used, '
        'the input\nfile is treated as a diceware wordlist (two columns).'
        '\nOptionally, -o | --output can be used to specify an output file '
        '(existing \nfile is overwritten).\n'
        'The number of words is {wordsamountmin} by default, but it '
        'can be changed by -w | --words.\n'
        'The number of numbers is {numsamountmin} by default, but it can be '
        'changed by\n-n | --numbers. The generated numbers are between '
        '{minnum} and {maxnum}.\n'
        'The default separator is a blank space, but any character or '
        'character\nsequence can be specified by -s | --separator.\n'
        '\nExample output:\n'
        '\tDefault parameters:\tchalice sheath postcard modular cider size\n'
        '\tWords=3, Numbers=2:\tdepraved widow office 184022 320264\n'
        '\tPassword, 20 chars:\tsF#s@B+iR#ZIL-yUWKPR'.format(
            minnum=passphrase.randnum_min,
            maxnum=passphrase.randnum_max,
            wordsamountmin=WORDS_AMOUNT_MIN_DEFAULT,
            numsamountmin=NUMS_AMOUNT_MIN_DEFAULT,
            passwdmin=PASSWD_LEN_MIN_GOOD,
            passwdpref=PASSWD_LEN_MIN_GOOD + 4,
            version=__version__
        )
    )

    parser.add_argument(
        "--version",
        action="store_true",
        help="print program version and licensing information and exit"
    )
    parser.add_argument(
        "--newline",
        action="store_true",
        default=False,
        help="print newline at the end of the passphrase/password"
    )
    parser.add_argument(
        "-q",
        "--quiet",
        action="store_true",
        default=False,
        help="quiet mode, it won't print anything but error messages "
             "(usefull with -o | --output)"
    )
    parser.add_argument(
        "-e",
        "--entropybits",
        type=bigger_than_zero,
        default=ENTROPY_BITS_MIN,
        help="specify the number of bits to use for entropy calculations "
             "(defaults to {})".format(ENTROPY_BITS_MIN)
    )
    parser.add_argument(
        "--uuid4",
        action="store_true",
        default=False,
        help="generate an UUID v4 string"
    )
    parser.add_argument(
        "-p",
        "--password",
        type=bigger_than_zero,
        const=-1,
        nargs='?',
        help="generate a password of the specified length from all printable "
             "or selected characters"
    )
    parser.add_argument(
        "--use-uppercase",
        type=bigger_than_zero,
        const=0,
        nargs='?',
        help="use uppercase characters for password generation or give the "
             "amount of uppercase characters in the passphrase: zero or no "
             "input for all uppercase or any number of uppercase "
             "characters wanted (the rest are lowercase)"
    )
    parser.add_argument(
        "--use-lowercase",
        type=bigger_than_zero,
        const=0,
        nargs='?',
        help="use lowercase characters for password generation or give the "
             "amount of lowercase characters in the passphrase: zero or no "
             "input for all lowercase (default) or any number of lowercase "
             "characters wanted (the rest are uppercase)"
    )
    parser.add_argument(
        "--use-digits",
        action="store_true",
        default=False,
        help="use digits for password generation"
    )
    parser.add_argument(
        "--use-alphanumeric",
        action="store_true",
        default=False,
        help="use lowercase and uppercase characters, and digits for password "
             "generation (equivalent to --use-lowercase --use-uppercase "
             "--use-digits)"
    )
    parser.add_argument(
        "--use-punctuation",
        action="store_true",
        default=False,
        help="use punctuation characters for password generation"
    )
    parser.add_argument(
        "-w",
        "--words",
        type=bigger_than_zero,
        help="specify the amount of words (0 or more)"
    )
    parser.add_argument(
        "-n",
        "--numbers",
        type=bigger_than_zero,
        default=NUMS_AMOUNT_MIN_DEFAULT,
        help="specify the amount of numbers (0 or more)"
    )
    parser.add_argument(
        "-s",
        "--separator",
        type=str,
        default=' ',
        help="specify a separator character (space by default)"
    )
    parser.add_argument(
        "-o",
        "--output",
        type=str,
        help="specify an output file (existing file is overwritten)"
    )
    parser.add_argument(
        "-i",
        "--input",
        type=str,
        help="specify an input file (it must have the following format: "
             "single column, one word per line)"
    )
    parser.add_argument(
        "-d",
        "--diceware",
        action="store_true",
        default=False,
        help="specify input file as a diceware list (format: two colums)"
    )

    args = parser.parse_args()

    inputfile = args.input
    outputfile = args.output
    separator = args.separator
    is_diceware = args.diceware
    passwordlen = args.password
    amount_w = args.words
    amount_n = args.numbers
    show_version = args.version
    quiet = args.quiet
    newline = args.newline
    uuid4 = args.uuid4
    p_uppercase = args.use_uppercase
    p_lowercase = args.use_lowercase
    p_digits = args.use_digits
    p_punctuation = args.use_punctuation
    p_alphanumeric = args.use_alphanumeric
    entropy_bits = args.entropybits

    if show_version is True:
        print_version()
        sys_exit()

    if entropy_bits < ENTROPY_BITS_MIN:
        Aux.print_stderr(
            "Warning: insecure number of bits for entropy calculations "
            "chosen! Should be bigger than {}".format(ENTROPY_BITS_MIN)
        )
    passphrase.entropy_bits_req = entropy_bits

    if uuid4 is True:
        # Generate uuid4
        passphrase.generate_uuid4()
        passphrase.separator = '-'
    elif passwordlen is not None:
        # Generate a password
        p_uppercase = True if p_uppercase is not None else False
        p_lowercase = True if p_lowercase is not None else False
        if (
            p_uppercase
            or p_lowercase
            or p_digits
            or p_punctuation
            or p_alphanumeric
        ):
            passphrase.password_use_uppercase = (p_uppercase or p_alphanumeric)
            passphrase.password_use_lowercase = (p_lowercase or p_alphanumeric)
            passphrase.password_use_digits = (p_digits or p_alphanumeric)
            passphrase.password_use_punctuation = p_punctuation

        min_len = passphrase.password_length_needed()
        if passwordlen < 1:
            passwordlen = min_len
        elif passwordlen < min_len:
            Aux.print_stderr(
                "Warning: Insecure password length chosen! Should be bigger "
                "than or equal to {}".format(min_len)
            )
        passphrase.passwordlen = passwordlen
        passphrase.generate_password()
        passphrase.separator = ''
    else:
        # Generate a passphrase

        # Read wordlist if indicated
        try:
            if inputfile is None:
                passphrase.load_internal_wordlist()
            else:
                passphrase.import_words_from_file(inputfile, is_diceware)

        except FileNotFoundError as err:
            Aux.print_stderr("Error: {}".format(err))
            sys_exit(1)

        passphrase.amount_n = amount_n
        amount_w_good = passphrase.words_amount_needed()
        if amount_w is None:
            amount_w = amount_w_good
        elif amount_w < amount_w_good:
            Aux.print_stderr(
                "Warning: Insecure amount of words chosen! Should be "
                "bigger than or equal to {}".format(amount_w_good)
            )

        passphrase.amount_w = amount_w
        case = (-1 * p_lowercase) if p_lowercase else p_uppercase
        passphrase.generate(case)
        passphrase.separator = separator

    if quiet is False:
        if newline is True:
            print(passphrase)
        else:
            print(passphrase, end='')

    if outputfile is not None:
        with open(outputfile, mode='wt', encoding='utf-8') as outfile:
            lf = '\n' if newline is True else ''
            outfile.write(str(passphrase) + lf)


if __name__ == "__main__":
    main()
