"""Passphrase: Generates cryptographically secure passphrases and passwords

Passphrases are built by picking from a word list using cryptographically
secure random number generator. Passwords are built from printable characters.
"""

from os.path import isfile
from string import digits, ascii_letters, punctuation
from .secrets import randbelow
from .calc import entropy_bits as calc_entropy_bits
from .calc import entropy_bits_nrange as calc_entropy_bits_nrange
from .calc import password_len_needed as calc_password_len_needed
from .calc import words_amount_needed as calc_words_amount_needed
from .settings import MIN_NUM, MAX_NUM, ENTROPY_BITS_MIN

__author__ = "HacKan"
__license__ = "GNU GPL 3.0+"
__version__ = "0.4.1"


class Passphrase():
    """Generates cryptographically secure passphrases and passwords

    Attributes:
        wordlist: A list of words to be consumed by the passphrase generator.
        amount_w: Amount of words to be generated by the passphrase generator.
        amount_n: Amount of numbers to be generated by the passphrase
                  generator.
        randnum_min: Minimum value for the random number in the passphrase.
        randnum_max: Maximum value for the random number in the passphrase.
        passwordlen: Length of the password.
        last_result: The last generated passphrase or password.
    """

    passwordlen = 12    # For EFF Large Wordlist
    amount_n = 0
    amount_w = 6        # For EFF Large Wordlist
    last_result = []
    randnum_min = MIN_NUM
    randnum_max = MAX_NUM
    entropy_bits_req = ENTROPY_BITS_MIN
    _wordlist = []
    _wordlist_entropy_bits = 0
    _external_wordlist = False

    def __init__(self,
                 inputfile: str = None,
                 is_diceware: bool = False) -> None:
        if inputfile is not None:
            self.import_words_from_file(inputfile, is_diceware)
        else:
            # Read default wordlist
            from json import loads as json_loads
            from pkg_resources import resource_string

            wordlist = json_loads(resource_string(
                'passphrase',
                'wordlist.json'
            ).decode('utf-8'))
            self._wordlist = wordlist['wordlist']
            self._wordlist_entropy_bits = wordlist['entropy_bits']

    @staticmethod
    def entropy_bits(lst: list) -> float:
        """Calculate the entropy of a wordlist or a numerical range

        Keyword arguments:
        lst -- A wordlist or a numerical range as a list: (minimum, maximum)

        Returns: float
        """
        size = len(lst)
        if (size == 2 and
                isinstance(lst[0], int) is True and
                isinstance(lst[1], int) is True):
            return calc_entropy_bits_nrange(lst[0], lst[1])

        return calc_entropy_bits(lst)

    @staticmethod
    def _read_words_from_wordfile(inputfile: str) -> list:
        if isfile(inputfile) is False:
            raise FileNotFoundError('Input file does not exists: '
                                    '{}'.format(inputfile))

        return [
            word.strip() for word in open(inputfile, mode='rt')
        ]

    @staticmethod
    def _read_words_from_diceware(inputfile: str) -> list:
        if isfile(inputfile) is False:
            raise FileNotFoundError('Input file does not exists: '
                                    '{}'.format(inputfile))

        return [
            word.split()[1] for word in open(inputfile, mode='rt')
        ]

    def import_words_from_file(self,
                               inputfile: str,
                               is_diceware: bool) -> None:
        if is_diceware is True:
            self._wordlist = self._read_words_from_diceware(inputfile)
        else:
            self._wordlist = self._read_words_from_wordfile(inputfile)
        self._external_wordlist = True

    def password_len_needed(self) -> float:
        return calc_password_len_needed(self.entropy_bits_req)

    def words_amount_needed(self) -> float:
        # Thanks to @julianor for this tip to calculate default amount of
        # entropy: minbitlen/log2(len(wordlist)).
        # I set the minimum entropy bits and calculate the amount of words
        # needed, cosidering the entropy of the wordlist.
        # Then: entropy_w * amount_w + entropy_n * amount_n >= ENTROPY_BITS_MIN
        entropy_n = self.entropy_bits((self.randnum_min, self.randnum_max))

        # The entropy for EFF Large Wordlist is ~12.9, no need to calculate
        if self._external_wordlist is False:
            entropy_w = self._wordlist_entropy_bits
        else:
            entropy_w = self.entropy_bits(self._wordlist)

        return calc_words_amount_needed(
            self.entropy_bits_req,
            entropy_w,
            entropy_n,
            self.amount_n
        )

    def stringify_last_result(self, separator: str = ' ') -> str:
        if self.last_result is None:
            return ''

        separator_len = len(separator)
        rm_last_separator = -separator_len if separator_len > 0 else None
        return "".join(
            '{}{}'.format(w, separator) for w in map(str, self.last_result)
        )[:rm_last_separator:]

    def generate(self,
                 wordlist: list = None,
                 amount_w: int = None,
                 amount_n: int = None) -> list:
        wordlist = self._wordlist if wordlist is None else wordlist
        amount_w = self.amount_w if amount_w is None else amount_w
        amount_n = self.amount_n if amount_n is None else amount_n

        passphrase = []
        for _ in range(0, amount_w):
            index = randbelow(len(wordlist))
            passphrase.append(wordlist[index])

        for _ in range(0, amount_n):
            num = randbelow(self.randnum_max - self.randnum_min + 1)
            num += self.randnum_min
            passphrase.append(num)

        self.last_result = passphrase
        return passphrase

    def generate_password(self, length: int = None) -> list:
        length = self.passwordlen if length is None else length
        characters = list(digits + ascii_letters + punctuation)
        password = self.generate(characters, length, 0)
        self.last_result = password
        return password
